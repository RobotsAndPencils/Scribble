//// Annotate Fonts v0.1.0// Draws indexed annotations beside font layers with a legend of font names and sizes// Tested with Photoshop CS6//// Copyright 2013 Brandon Evans// Released under MIT License//#target photoshop#script "Annotate Fonts"#strict oninit();showDialog();function showDialog() {     var windowResource = "dialog {  \        orientation: 'column', \        alignChildren: ['fill', 'bottom'],  \        preferredSize:[350, 50], \        text: 'Annotate Fonts',  \        margins:15, \        \        bottomGroup: Group{ \            retinaCheckbox: Checkbox { text: 'Retina', value: true }, \            cancelButton: Button { text: 'Cancel', properties:{name:'cancel'}, size: [120,24], alignment:['right', 'center'] }, \            currentButton: Button { text: 'Current Document', properties:{name:'current'}, size: [150,24], alignment:['right', 'center'] }, \            directoryButton: Button { text: 'Directory', properties:{name:'directory'}, size: [120,24], alignment:['right', 'center'] }, \        }\    }";    var win = new Window(windowResource);    win.bottomGroup.cancelButton.onClick = function() {        win.close();        return true;    };    win.bottomGroup.currentButton.onClick = function() {        win.close();        if (validateState()) {            app.activeDocument.suspendHistory("Annotate Fonts", "annotateFonts(app.activeDocument, scale());");        }        return true;    };    win.bottomGroup.directoryButton.onClick = function() {        win.close();        annotateDirectory(scale());        return true;    };    function scale() {        if (win.bottomGroup.retinaCheckbox.value) {            return 2;        } else {            return 1;        }    }    win.show();}function annotateFonts(docRef, scale) {    // Colors used for annotation    var orange = new SolidColor();    orange.rgb.red = 255;    orange.rgb.green = 127;    orange.rgb.blue = 0;    var white = new SolidColor();    white.rgb.red = 255;    white.rgb.green = 255;    white.rgb.blue = 255;    // Ensure the Fonts layer group exists    try {        mainLayerSet = docRef.layerSets.getByName("Font Annotations");    } catch (error) {        mainLayerSet = docRef.layerSets.add();        mainLayerSet.name = "Font Annotations";    }    var allLayers = getLayersList(docRef);    if (allLayers.length === 0) return;    // Iterate through all layers and collect font and layer references    var fontArray = new Array; // List of font names    var layerFontMap = {}; // Map from layer reference to font name    var layer, fontName;    for (var index = 0; index < allLayers.length; ++index) {        layer = allLayers[index];        var validLayer = layer.kind == LayerKind.TEXT && layer.opacity > 0.0 && layer.visible == true;        if (validLayer) {            var font = layer.textItem.font            var size = (layer.textItem.size.as("pt") / scale).toPrecision(2) + "pt";            var color = "#" + layer.textItem.color.rgb.hexValue;            var fontString = [font, size, color].join(", ");            fontArray.push(fontString);            fontArray = fontArray.unique();            var fontIndex = fontArray.indexOf(fontString);            layerFontMap[layer] = fontIndex;            drawIndexAnnotation(mainLayerSet, layer, fontIndex + 1, scale, orange, white);        }    };    // Draw the font legend    var layerSetRef = mainLayerSet.layerSets.add()    var textLayerRef = layerSetRef.artLayers.add();    textLayerRef.kind = LayerKind.TEXT;    var textItemRef = textLayerRef.textItem;    var padding = 25 * scale;    textItemRef.position = Array(padding, padding);    textItemRef.name = "Font Legend";    textItemRef.color = white;    textItemRef.font = "LucidaGrande-Bold";    textItemRef.size = new UnitValue(12 * scale, "pt");    var legendString = "";    for (var index = 0; index < fontArray.length; ++index) {        var fontString = fontArray[index];        legendString = legendString + (index + 1).toString() + ": " + fontString + String.fromCharCode(13);    }    textItemRef.contents = legendString;    // Add a background behind the legend    var shapeLayerRef = layerSetRef.artLayers.add();    shapeLayerRef.move(textLayerRef, ElementPlacement.PLACEAFTER);    var bgBounds = boundsInset(textLayerRef.bounds, -15);    drawRect(bgBounds, orange);}function annotateDirectory(scale) {    var selectedFolder = Folder.selectDialog("Please select the directory of files to annotate", Folder("~"));    if (selectedFolder == null) return;    var psdFiles = selectedFolder.findFiles(/\.psd$|\.PSD$/);    for (var i = 0; i < psdFiles.length; i++) {        var doc = open(psdFiles[i]);        doc.suspendHistory("Annotate Fonts", "annotateFonts(doc, scale);");    };}// Ensure PS is ready to annotate fontsfunction validateState() {    if (app.documents.length == 0) {        alert("No document open");        return false;    }    return true;}function init() {    // PS only seems to load standard objects once needed    // We need to add these methods after an array has been created    var array = new Array();    Array.prototype.unique = function() {        var unique = [];        for (var i = 0; i < this.length; i += 1) {            if (unique.indexOf(this[i]) == -1) {                unique.push(this[i])            }        }        return unique;    };    Array.prototype.indexOf = function(searchElement) {        "use strict";        if (this == null) {            throw new TypeError();        }        var t = Object(this);        var len = t.length >>> 0;        if (len === 0) {            return -1;        }        var n = 0;        if (arguments.length > 1) {            n = Number(arguments[1]);            if (n != n) { // shortcut for verifying if it's NaN                n = 0;            } else if (n != 0 && n != Infinity && n != -Infinity) {                n = (n > 0 || -1) * Math.floor(Math.abs(n));            }        }        if (n >= len) {            return -1;        }        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);        for (; k < len; k++) {            if (k in t && t[k] === searchElement) {                return k;            }        }        return -1;    }    Stdlib = function Stdlib() {};    Stdlib.findFiles = function (folder, mask) { //from Xbytor's Xtools        var files = Stdlib.getFiles(folder, mask);        var folders = Stdlib.getFolders(folder);        for (var i = 0; i < folders.length; i++) {            var f = folders[i];            var ffs = Stdlib.findFiles(f, mask);            while (ffs.length > 0) {                files.push(ffs.shift());            }        }        return files;    };    Stdlib.getFiles = function (folder, mask) {        var files = [];        var getF;        if (Folder.prototype._getFiles) {            getF = function (f, m) {                return f._getFiles(m);            }        } else {            getF = function (f, m) {                return f.getFiles(m);            }        }        if (mask instanceof RegExp) {            var allFiles = getF(folder);            for (var i = 0; i < allFiles.length; i = i + 1) {                var f = allFiles[i];                if (decodeURI(f.absoluteURI).match(mask)) {                    files.push(f);                }            }        } else if (typeof mask == "function") {            var allFiles = getF(folder);            for (var i = 0; i < allFiles.length; i = i + 1) {                var f = allFiles[i];                if (mask(f)) {                    files.push(f);                }            }        } else {            files = getF(folder, mask);        }        return files;    };    Stdlib.getFolders = function (folder) {        return Stdlib.getFiles(folder, function (file) {            return file instanceof Folder;        });    }    Folder.prototype.findFiles = function (mask) {        return Stdlib.findFiles(this, mask);    };}// Draw a font index annotation beside a font item layerfunction drawIndexAnnotation(mainLayerSet, sourceLayer, index, scale, bgColor, fgColor) {    var layerSetRef = mainLayerSet.layerSets.add()    var y1 = sourceLayer.bounds[1].value;    var x2 = sourceLayer.bounds[2].value;    var y2 = sourceLayer.bounds[3].value;    var padding = 7 * scale, radius = 10 * scale, fontSize = 12 * scale;    var shapeLayerRef = layerSetRef.artLayers.add();    drawCircle(x2 + padding, y1 + ((y2 - y1) / 2 - radius), radius, bgColor);    var textLayerRef = layerSetRef.artLayers.add();    textLayerRef.kind = LayerKind.TEXT;    var textItemRef = textLayerRef.textItem;    textItemRef.kind = TextType.PARAGRAPHTEXT;    textItemRef.position = Array(x2 + padding, y1 + ((y2 - y1) / 2 - radius));    textItemRef.width = radius * 2;    textItemRef.height = radius * 2;    textItemRef.justification = Justification.CENTER;    textItemRef.baselineShift = -(radius - fontSize / 2);    textItemRef.contents = index;    textItemRef.name = textItemRef.contents;    textItemRef.color = fgColor;    textItemRef.font = "LucidaGrande-Bold";    textItemRef.size = new UnitValue(fontSize, "pt");}// Return a new array of UnitValues describing bounds that have been insetfunction boundsInset(bounds, inset) {    var newBounds = [        new UnitValue(bounds[0].value + inset, bounds[0].type),        new UnitValue(bounds[1].value + inset, bounds[1].type),        new UnitValue(bounds[2].value - inset, bounds[2].type),        new UnitValue(bounds[3].value - inset, bounds[3].type)    ];    return newBounds;}function drawCircle(left, top, radius, color) {    var points = [        { anchor: [left + radius, top], right: [left + radius / 2, top], left: [left + radius * 1.5, top] },        { anchor: [left + radius * 2, top + radius], right: [left + radius * 2, top + radius / 2], left: [left + radius * 2, top + radius * 1.5] },        { anchor: [left + radius, top + radius * 2], right: [left + radius * 1.5, top + radius * 2], left: [left + radius / 2, top + radius * 2] },        { anchor: [left, top + radius], right: [left, top + radius * 1.5], left: [left, top + radius / 2] }    ];    var lineArray = [];    for (var i = 0; i < points.length; ++i) {        lineArray[i] = new PathPointInfo;        lineArray[i].kind = PointKind.SMOOTHPOINT;        lineArray[i].anchor = points[i].anchor;        lineArray[i].leftDirection = points[i].left;        lineArray[i].rightDirection = points[i].right;    }    var lineSubPathArray = new SubPathInfo();    lineSubPathArray.closed = true;    lineSubPathArray.operation = ShapeOperation.SHAPEADD;    lineSubPathArray.entireSubPath = lineArray;    var myPathItem = app.activeDocument.pathItems.add("circle", [lineSubPathArray]);    var desc88 = new ActionDescriptor();    var ref60 = new ActionReference();    ref60.putClass(stringIDToTypeID("contentLayer"));    desc88.putReference(charIDToTypeID("null"), ref60);    var desc89 = new ActionDescriptor();    var desc90 = new ActionDescriptor();    var desc91 = new ActionDescriptor();    desc91.putDouble(charIDToTypeID("Rd  "), color.rgb.red); // R    desc91.putDouble(charIDToTypeID("Grn "), color.rgb.green); // G    desc91.putDouble(charIDToTypeID("Bl  "), color.rgb.blue); // B    var id481 = charIDToTypeID("RGBC");    desc90.putObject(charIDToTypeID("Clr "), id481, desc91);    desc89.putObject(charIDToTypeID("Type"), stringIDToTypeID("solidColorLayer"), desc90);    desc88.putObject(charIDToTypeID("Usng"), stringIDToTypeID("contentLayer"), desc89);    executeAction(charIDToTypeID("Mk  "), desc88, DialogModes.NO);    myPathItem.remove();};function drawRect(bounds, color) {    var x1 = bounds[0].value,        y1 = bounds[1].value,        x2 = bounds[2].value,        y2 = bounds[3].value;    var points = [        [x1, y1],        [x2, y1],        [x2, y2],        [x1, y2]    ];    var lineArray = [];    for (var i = 0; i < points.length; ++i) {        lineArray[i] = new PathPointInfo;        lineArray[i].kind = PointKind.SMOOTHPOINT;        lineArray[i].anchor = points[i];        lineArray[i].leftDirection = lineArray[i].anchor;        lineArray[i].rightDirection = lineArray[i].anchor;    }    var lineSubPathArray = new SubPathInfo();    lineSubPathArray.closed = true;    lineSubPathArray.operation = ShapeOperation.SHAPEADD;    lineSubPathArray.entireSubPath = lineArray;    var myPathItem = app.activeDocument.pathItems.add("circle", [lineSubPathArray]);    var desc88 = new ActionDescriptor();    var ref60 = new ActionReference();    ref60.putClass(stringIDToTypeID("contentLayer"));    desc88.putReference(charIDToTypeID("null"), ref60);    var desc89 = new ActionDescriptor();    var desc90 = new ActionDescriptor();    var desc91 = new ActionDescriptor();    desc91.putDouble(charIDToTypeID("Rd  "), color.rgb.red); // R    desc91.putDouble(charIDToTypeID("Grn "), color.rgb.green); // G    desc91.putDouble(charIDToTypeID("Bl  "), color.rgb.blue); // B    var id481 = charIDToTypeID("RGBC");    desc90.putObject(charIDToTypeID("Clr "), id481, desc91);    desc89.putObject(charIDToTypeID("Type"), stringIDToTypeID("solidColorLayer"), desc90);    desc88.putObject(charIDToTypeID("Usng"), stringIDToTypeID("contentLayer"), desc89);    executeAction(charIDToTypeID("Mk  "), desc88, DialogModes.NO);    myPathItem.remove();};function _traverse(doc, layers, ftn, reverse) {    var ok = true;    for (var i = 1; i <= layers.length && ok != false; i++) {        var index = (reverse == true) ? layers.length - i : i - 1;        var layer = layers[index];        if (layer.typename == "LayerSet") {            ok = _traverse(doc, layer.layers, ftn, reverse);        } else {            ok = ftn(doc, layer);        }    }    return ok;};function traverseLayers(doc, ftn, reverse) { //from Xbytor    return _traverse(doc, doc.layers, ftn, reverse);};function getLayersList(doc, reverse) {    function _ftn(doc, layer) {        if (layer.kind == LayerKind.TEXT) {            _ftn.list.push(layer);        };    };    _ftn.list = [];    traverseLayers(doc, _ftn, reverse);    return _ftn.list;};